use std::io::Write;
use std::path::PathBuf;
use bpaf::Bpaf;
use env_logger::Builder;
use env_logger::fmt::Color::*;
use log::{debug, error, info, LevelFilter, warn};
use flashy64_backend::carts::{Cic, SaveType};
use flashy64_backend::Error;

#[derive(Debug, Bpaf)]
#[bpaf(options, version, generate(args))]
struct Args {
    /// Upload file at this path to the cartridge's ROM space.
    #[bpaf(long, short)]
    upload: Option<PathBuf>,
    
    /// Specifies which CIC variant should be used. Note! 64drive HW1 does not support setting the CIC.
    ///   Options: auto, 6101, 6102, 7101, 7102, x103, x105, x106, or 5101
    #[bpaf(long, short)]
    cic: Option<Cic>,
    
    /// Specifies which cartridge savetype the rom expects. Autodetection requires --upload to be used.
    ///   Options: auto, eeprom4kbit, eeprom16kbit, sram256kbit, flashram1mbit, sram768kbit, pokestadium2, or none
    #[bpaf(long, short)]
    savetype: Option<SaveType>,
    
    /// List available USB devices.
    #[bpaf(long, short)]
    list: bool,
    
    /// Specify the device to use, by its serial number. Otherwise the first valid device is used by default.
    #[bpaf(long, short)]
    device: Option<String>,
    
    /// Enables UNFLoader support. Program will stay open until the user quits (CTRL+C).
    ///   (Sending data via UNFLoader to cartridge is not supported yet)
    #[bpaf(long)]
    unf: bool,
    
    /// On linux, the default ftdi_sio driver conflicts with D2XX. This command requires sudo, and will save
    /// a blacklist command to /etc/modprobe.d/ftdi_sio-blacklist.conf, to automatically disable ftdi_sio when a
    /// flashcart is plugged in. Otherwise you will be required to run 'sudo rmmod ftdi_sio' whenever connecting a flashcart.
    #[cfg(target_os = "linux")]
    #[bpaf(long)]
    disable_sio: bool,
    
    /// Set the console log level. Environment variable 'RUST_LOG' will override this option.
    ///   Options: error, warn, info, debug, trace
    #[bpaf(long, short)]
    verbose: Option<LevelFilter>,
}

fn main() {
    let args: Args = args().run();
    
    {
        let mut logbuilder = logger_builder();
        logbuilder.filter_level(args.verbose.unwrap_or(LevelFilter::Info));
        logbuilder.init();
    }
    
    #[cfg(target_os = "linux")]
    if args.disable_sio {
        match std::fs::write("/etc/modprobe.d/ftdi_sio-blacklist.conf", "# Generated by flashy64 to fix compatibility issue between FTDI 2DXX driver and ftdi_sio\nblacklist ftdi_sio") {
            Ok(()) => info!("File written. Any currently connected flashcarts should be unplugged, and reconnected."),
            Err(err) => match err.kind() {
                std::io::ErrorKind::PermissionDenied => error!("Insufficient permissions. Please run program as root (e.g. sudo flashy64 --disable-sio)."),
                _ => error!("Err: {}", err)
            }
        }
        return;
    }
    
    if args.list {
        if let Ok(carts) = flashy64_backend::carts() {
            if !carts.is_empty() {
                info!("Available flashcarts:");
                for mut cart in carts {
                    let info = cart.info().unwrap();
                    //TODO: Print version info using VERSION_REQUEST command function
                    info!("{} : {}", info.serial_number, info.description);
                }
            } else {
                info!("No flashcarts available. If you believe this is wrong, try running with the `-v debug` option, and see if any devices are in use (port_open == true).");
            }
        }
        
        return;
    }
    
    
    let mut cart = match args.device {
        Some(serial) => flashy64_backend::from_serial(serial).expect("Failed to open device with serial: {serial}"),
        None => {
            debug!("Defaulting to first valid device...");
            
            let mut carts = flashy64_backend::carts().expect("Failed to retrieve device list");
            if carts.is_empty() {
                panic!("No flashcarts available. If you believe this is wrong, try running with the `-v debug` option, and see if any devices are in use (port_open == true).");
            }
            
            carts.remove(0)
        }
    };
    
    if let Some(ref path) = args.upload {
        let data = std::fs::read(path).unwrap();
        
        match cart.upload_rom(&data) {
            Ok(_) => info!("ROM Upload Complete."),
            Err(err) => error!("Err: {:?}", err)
        }
    }
    
    if let Some(mut cic) = args.cic {
        if cic == Cic::Auto {
            let mut ipl3 = cart.download_rom(0x1000).unwrap_or_default();
            ipl3.resize(0x1000, 0x00);
            cic = Cic::from_ipl3(&ipl3[0x40..]);
        }
        
        match cic {
            Cic::Unknown | Cic::Auto => error!("Unable to determine CIC type index."),
            _ => match cart.set_cic(cic) {
                Ok(_) => info!("CIC Configured."),
                Err(err) => error!("Err: {:?}", err)
            }
        }
    }
    
    if let Some(mut savetype) = args.savetype {
        if savetype == SaveType::Auto {
            if let Some(ref path) = args.upload {
                let data = std::fs::read(path).unwrap();
                savetype = SaveType::from_rom(&data);
            } else {
                warn!("Savetype autodection requires --upload to be used.");
                savetype = SaveType::Unknown;
            }
        }
        
        match savetype {
            SaveType::Unknown => (),
            SaveType::Auto => error!("Unable to determine SaveType index."),
            _ => match cart.set_savetype(savetype) {
                Ok(_) => info!("SaveType Configured."),
                Err(err) => error!("Err: {:?}", err)
            }
        }
    }
    
    if args.unf {
        loop {
            use flashy64_backend::unfloader::DataType::*;
            
            match cart.recv_debug() {
                Ok((kind, data)) => match kind {
                    Text => print!("{}", std::str::from_utf8(&data).unwrap_or_default()),
                    _ => println!("Unsupported data type: {kind:?}")
                },
                Err(err) => match err {
                    Error::FtdiTimeout(_) => continue,
                    _ => panic!("{err:?}"),
                }
            }
        }
    }
}




fn logger_builder() -> Builder {
    let mut builder = Builder::new();
    
    builder.format(|f, record| {
        use log::Level::*;
        
        let mut style = f.style();
        let level = match record.level() {
            Trace => style.set_color(Magenta).value("TRACE"),
            Debug => style.set_color(Blue).value("DEBUG"),
            Info => style.set_color(Green).value("INFO"),
            Warn => style.set_color(Yellow).value("WARN"),
            Error => style.set_color(Red).value("ERROR"),
        };
        
        writeln!(f, "[{}] {}",
            level,
            record.args()
        )
    });
    
    builder
}